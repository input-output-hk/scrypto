package scorex.crypto.hash

import typings.nobleHashes.blake2Mod.BlakeOpts
import typings.nobleHashes.blake2bMod.blake2b
import typings.nobleHashes.sha256Mod.sha256
import typings.nobleHashes.utilsMod

import scala.scalajs.js.typedarray.Uint8Array

/** JS platform specific implementation of methods.
  * When shared code is compiled to JS, this implementation is used.
  *
  * The JS implementation is based on type wrappers generated by ScalablyTyped for the
  * @noble/hashes library. (See configuration in build.sbt.)
  *
  * @see jvm/src/main/scala/scorex/crypto/hash/Platform.scala for JVM implementation
  */
object Platform {

  /** Represents abstract digest from @noble.
    * See createBlake2bDigest, createSha256Digest methods.
    */
  type Digest = utilsMod.Hash[_]

  private def bytesToShorts(xs: Array[Byte]): Array[Short] =
    xs.map(x => (x & 0xFF).toShort)

  private def uint8ArrayToBytes(jsShorts: Uint8Array): Array[Byte] = {
    jsShorts.toArray[Short].map(x => x.toByte)
  }

  /** Creates an implementation of the cryptographic hash function Blakbe2b.
    *
    * @param bitSize the bit size of the digest
    * @return the digest implementation
    */
  def createBlake2bDigest(bitSize: Int): Digest = {
    val opts = BlakeOpts().setDkLen(bitSize / 8)
    blake2b.create(opts)
  }

  /** Creates an implementation of the cryptographic hash function SHA-256.
    *
    * @return the digest implementation
    */
  def createSha256Digest(): Digest = {
    sha256.create()
  }

  /** Update the message digest with a single byte.
    *
    * @param digest the digest to be updated
    * @param b      the input byte to be entered.
    */
  def updateDigest(digest: Digest, b: Byte): Unit = {
    digest.update(Uint8Array.of((b & 0xFF).toShort))
  }

  /** Update the message digest with a block of bytes.
    *
    * @param digest the digest to be updated
    * @param bytes     the byte array containing the data.
    * @param inOff  the offset into the byte array where the data starts.
    * @param inLen  the length of the data.
    */
  def updateDigest(digest: Digest,
                   bytes: Array[Byte],
                   inOff: Int,
                   inLen: Int): Unit = {
    val in = Uint8Array.of(bytesToShorts(bytes.slice(inOff, inOff + inLen)): _*)
    digest.update(in)
  }

  /** Close the digest, producing the final digest value. The doFinal
    * call leaves the digest reset.
    * A new array is created to store the result.
    *
    * @param digest the digest to be finalized
    */
  def doFinalDigest(digest: Digest): Array[Byte] = {
    val res = digest.digest()
    uint8ArrayToBytes(res)
  }
}
